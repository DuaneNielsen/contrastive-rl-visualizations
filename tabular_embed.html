<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabular SGCRL - Embed</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100vh;
            gap: 1px;
            background: #2a2a3a;
        }
        .panel {
            background: #12121a;
            position: relative;
            overflow: hidden;
        }
        .panel-title {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.8);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            z-index: 10;
        }
        #maze-canvas { width: 100%; height: 100%; }

        /* Floating controls */
        #controls-toggle {
            position: fixed;
            bottom: 12px;
            left: 12px;
            background: #3355aa;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        #controls-toggle:hover { background: #4466cc; }

        #controls-panel {
            position: fixed;
            bottom: 50px;
            left: 12px;
            background: rgba(18, 18, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            z-index: 99;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
            max-width: 200px;
        }
        #controls-panel.visible { display: block; }

        #controls-panel button {
            background: #3355aa;
            color: white;
            border: none;
            padding: 6px 10px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
        }
        #controls-panel button:hover { background: #4466cc; }
        #controls-panel button.active { background: #44aa66; }

        .mini-stats {
            font-size: 0.7em;
            margin-top: 8px;
            color: #888;
        }
        .mini-stats span { color: #8abb9a; }

        /* Colorbar */
        .colorbar {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 120px;
            border-radius: 3px;
            background: linear-gradient(to bottom, #5a78a0, #8a7080, #b4645a);
        }
        .colorbar-label {
            position: absolute;
            right: 24px;
            font-size: 0.6em;
            color: #666;
        }
        .colorbar-label.top { top: 50%; transform: translateY(-80px); }
        .colorbar-label.bottom { top: 50%; transform: translateY(70px); }

        /* View buttons */
        .view-btns { margin-top: 6px; }
        .view-btns button { padding: 4px 8px; font-size: 0.7em; }
    </style>
</head>
<body>
    <div id="container">
        <div class="panel" id="maze-panel">
            <div class="panel-title">Maze: ψ-similarity</div>
            <canvas id="maze-canvas"></canvas>
            <div class="colorbar"></div>
            <div class="colorbar-label top">goal</div>
            <div class="colorbar-label bottom">squeezed</div>
        </div>
        <div class="panel" id="repr-panel">
            <div class="panel-title" id="repr-title">Representations</div>
        </div>
    </div>

    <button id="controls-toggle">▶ Play</button>

    <div id="controls-panel" class="visible">
        <div>
            <button id="btn-play">▶ Play</button>
            <button id="btn-reset">Reset</button>
        </div>
        <div class="view-btns">
            <button id="btn-view-pca3d" class="active">3D</button>
            <button id="btn-view-pca2d">2D</button>
            <button id="btn-view-magnitude">||ζ||</button>
        </div>
        <div class="mini-stats">
            Ep: <span id="stat-episode">0</span> |
            Success: <span id="stat-success-rate">0%</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ============================================
        // MATH UTILITIES
        // ============================================
        const MathUtils = {
            randomVector(dim) {
                const v = [];
                for (let i = 0; i < dim; i++) v.push((Math.random() - 0.5) * 2);
                return v;
            },
            normalize(v) {
                let norm = 0;
                for (let i = 0; i < v.length; i++) norm += v[i] * v[i];
                norm = Math.sqrt(norm) + 1e-8;
                for (let i = 0; i < v.length; i++) v[i] /= norm;
            },
            dot(a, b) {
                let sum = 0;
                for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
                return sum;
            }
        };
        const { randomVector, normalize, dot } = MathUtils;

        // ============================================
        // FOUR ROOMS ENVIRONMENT
        // ============================================
        class FourRoomsEnv {
            constructor(height = 11, width = 11, goalPos = [10, 10], startPos = [0, 0]) {
                this.height = height;
                this.width = width;
                this.goalPos = goalPos;
                this.startPos = startPos;
                this.numStates = height * width;
                this.numActions = 5;
                this.actions = [[0,0], [1,0], [-1,0], [0,1], [0,-1]];
                this.goalState = this.posToState(goalPos[0], goalPos[1]);
                this.startState = this.posToState(startPos[0], startPos[1]);
                this.walls = this._buildWalls();
            }
            _buildWalls() {
                const walls = [];
                for (let i = 0; i < this.height; i++) {
                    walls[i] = [];
                    for (let j = 0; j < this.width; j++) walls[i][j] = 0;
                }
                for (let j = 0; j < this.width; j++) walls[Math.floor(this.height/2)][j] = 1;
                for (let i = 0; i < this.height; i++) walls[i][Math.floor(this.width/2)] = 1;
                const doorLen = 2;
                for (let d = 0; d < doorLen; d++) {
                    walls[Math.floor(this.height/2)][Math.floor(this.width/4) + d] = 0;
                    walls[Math.floor(this.height/2)][Math.floor(3*this.width/4) + d] = 0;
                    walls[Math.floor(this.height/4) + d][Math.floor(this.width/2)] = 0;
                    walls[Math.floor(3*this.height/4) + d][Math.floor(this.width/2)] = 0;
                }
                return walls;
            }
            posToState(i, j) { return i * this.width + j; }
            stateToPos(s) { return [Math.floor(s / this.width), s % this.width]; }
            isWall(i, j) { return this.walls[i] && this.walls[i][j] === 1; }
            step(state, action) {
                const [i, j] = this.stateToPos(state);
                const [di, dj] = this.actions[action];
                const ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < this.height && nj >= 0 && nj < this.width && !this.isWall(ni, nj)) {
                    return this.posToState(ni, nj);
                }
                return state;
            }
            isGoal(state) { return state === this.goalState; }
        }

        // ============================================
        // TABULAR REPRESENTATION
        // ============================================
        class TabularRepresentation {
            constructor(numStates, repDim, goalState) {
                this.numStates = numStates;
                this.repDim = repDim;
                this.goalState = goalState;
                this.psi = null;
                this.psiGoal = null;
            }
            init() {
                this.psi = [];
                this.psiGoal = randomVector(this.repDim);
                normalize(this.psiGoal);
                for (let s = 0; s < this.numStates; s++) {
                    const v = this.psiGoal.slice();
                    for (let d = 0; d < this.repDim; d++) v[d] += (Math.random() - 0.5) * 0.2;
                    normalize(v);
                    this.psi[s] = v;
                }
                this.psi[this.goalState] = this.psiGoal.slice();
            }
            getRepresentation(state) { return this.psi[state]; }
            getGoalRepresentation() { return this.psiGoal; }
            goalSimilarity(state) { return dot(this.psi[state], this.psiGoal); }
            applyGradients(sBatch, spBatch, anchorGrads, positiveGrads, lr) {
                for (let i = 0; i < sBatch.length; i++) {
                    const s = sBatch[i];
                    for (let d = 0; d < this.repDim; d++) this.psi[s][d] += lr * anchorGrads[i][d];
                }
                for (let j = 0; j < spBatch.length; j++) {
                    const sp = spBatch[j];
                    for (let d = 0; d < this.repDim; d++) this.psi[sp][d] += lr * positiveGrads[j][d];
                }
            }
            normalizeAll() { for (let s = 0; s < this.numStates; s++) normalize(this.psi[s]); }
            fixGoalRepresentation() {
                for (let d = 0; d < this.repDim; d++) this.psi[this.goalState][d] = this.psiGoal[d];
            }
        }

        // ============================================
        // INFONCE LOSS
        // ============================================
        const InfoNCE = {
            computeLossAndGradients(psiS, psiP, repDim) {
                const B = psiS.length;
                const dots = [];
                for (let i = 0; i < B; i++) {
                    dots[i] = [];
                    for (let j = 0; j < B; j++) dots[i][j] = dot(psiS[i], psiP[j]);
                }
                const P = [];
                for (let i = 0; i < B; i++) P[i] = new Array(B);
                for (let j = 0; j < B; j++) {
                    let maxVal = -Infinity;
                    for (let i = 0; i < B; i++) maxVal = Math.max(maxVal, dots[i][j]);
                    let sumExp = 0;
                    for (let i = 0; i < B; i++) {
                        P[i][j] = Math.exp(dots[i][j] - maxVal);
                        sumExp += P[i][j];
                    }
                    for (let i = 0; i < B; i++) P[i][j] /= sumExp;
                }
                let loss = 0;
                for (let i = 0; i < B; i++) loss -= Math.log(P[i][i] + 1e-12);
                loss /= B;
                const anchorGrads = [];
                for (let i = 0; i < B; i++) {
                    const grad = new Array(repDim).fill(0);
                    for (let j = 0; j < B; j++) {
                        const coeff = (i === j ? 1 : 0) - P[i][j];
                        for (let d = 0; d < repDim; d++) grad[d] += coeff * psiP[j][d];
                    }
                    anchorGrads.push(grad);
                }
                const positiveGrads = [];
                for (let j = 0; j < B; j++) {
                    const expected = new Array(repDim).fill(0);
                    for (let i = 0; i < B; i++) {
                        for (let d = 0; d < repDim; d++) expected[d] += P[i][j] * psiS[i][d];
                    }
                    const grad = new Array(repDim);
                    for (let d = 0; d < repDim; d++) grad[d] = psiS[j][d] - expected[d];
                    positiveGrads.push(grad);
                }
                return { loss, anchorGrads, positiveGrads };
            }
        };

        // ============================================
        // SGCRL AGENT
        // ============================================
        class SGCRLAgent {
            constructor(env, representation, config = {}) {
                this.env = env;
                this.repr = representation;
                this.replayCapacity = config.replayCapacity || 200;
                this.batchSize = config.batchSize || 64;
                this.gamma = config.gamma || 0.99;
                this.lr = config.lr || 0.02;
                this.entropyCoeff = config.entropyCoeff || 0.1;
                this.maxSteps = config.maxSteps || 50;
                this.replay = [];
            }
            init() {
                this.repr.init();
                this.replay = [];
            }
            selectAction(state) {
                const psiGoal = this.repr.getGoalRepresentation();
                const similarities = [];
                for (let a = 0; a < this.env.numActions; a++) {
                    const ns = this.env.step(state, a);
                    similarities.push(dot(this.repr.getRepresentation(ns), psiGoal));
                }
                const invTemp = 1.0 / this.entropyCoeff;
                const maxSim = Math.max(...similarities);
                const expSims = similarities.map(s => Math.exp((s - maxSim) * invTemp));
                const sumExp = expSims.reduce((a, b) => a + b, 0);
                const probs = expSims.map(e => e / sumExp);
                const r = Math.random();
                let cumsum = 0;
                for (let a = 0; a < this.env.numActions; a++) {
                    cumsum += probs[a];
                    if (r < cumsum) return a;
                }
                return this.env.numActions - 1;
            }
            collectEpisode() {
                const traj = [this.env.startState];
                let success = false;
                for (let t = 0; t < this.maxSteps; t++) {
                    const action = this.selectAction(traj[traj.length - 1]);
                    const ns = this.env.step(traj[traj.length - 1], action);
                    traj.push(ns);
                    if (this.env.isGoal(ns)) { success = true; break; }
                }
                this.replay.push(traj);
                if (this.replay.length > this.replayCapacity) this.replay.shift();
                return { traj, success };
            }
            sampleBatch() {
                const sBatch = [], spBatch = [];
                for (let b = 0; b < this.batchSize; b++) {
                    const trajIdx = Math.floor(Math.random() * this.replay.length);
                    const traj = this.replay[trajIdx];
                    if (traj.length < 2) continue;
                    const i = Math.floor(Math.random() * (traj.length - 1));
                    const remaining = traj.length - i - 1;
                    if (remaining < 1) continue;
                    const weights = [];
                    for (let k = 0; k < remaining; k++) weights.push(Math.pow(this.gamma, k));
                    const sumW = weights.reduce((a, b) => a + b, 0);
                    const r = Math.random() * sumW;
                    let cumsum = 0, offset = 1;
                    for (let k = 0; k < remaining; k++) {
                        cumsum += weights[k];
                        if (r < cumsum) { offset = k + 1; break; }
                    }
                    sBatch.push(traj[i]);
                    spBatch.push(traj[i + offset]);
                }
                return { sBatch, spBatch };
            }
            updateRepresentations() {
                if (this.replay.length < 2) return 0;
                const { sBatch, spBatch } = this.sampleBatch();
                if (sBatch.length === 0) return 0;
                const psiS = sBatch.map(s => this.repr.getRepresentation(s).slice());
                const psiP = spBatch.map(s => this.repr.getRepresentation(s).slice());
                const { loss, anchorGrads, positiveGrads } = InfoNCE.computeLossAndGradients(psiS, psiP, this.repr.repDim);
                this.repr.applyGradients(sBatch, spBatch, anchorGrads, positiveGrads, this.lr);
                this.repr.normalizeAll();
                this.repr.fixGoalRepresentation();
                return loss;
            }
        }

        // ============================================
        // INSTANTIATE
        // ============================================
        const REP_DIM = 64;
        const env = new FourRoomsEnv();
        const representation = new TabularRepresentation(env.numStates, REP_DIM, env.goalState);
        const agent = new SGCRLAgent(env, representation);

        const HEIGHT = env.height, WIDTH = env.width;
        const walls = env.walls;
        const NUM_STATES = env.numStates;
        const GOAL_STATE = env.goalState, START_STATE = env.startState;

        function stateToPos(s) { return env.stateToPos(s); }
        function goalSimilarity(state) { return representation.goalSimilarity(state); }

        // ============================================
        // MAZE VISUALIZATION
        // ============================================
        const mazeCanvas = document.getElementById('maze-canvas');
        const mazeCtx = mazeCanvas.getContext('2d');
        let currentTraj = [];
        let currentTrajSuccess = false;

        function resizeMazeCanvas() {
            const panel = document.getElementById('maze-panel');
            mazeCanvas.width = panel.clientWidth;
            mazeCanvas.height = panel.clientHeight;
        }

        function drawMaze() {
            const cellW = mazeCanvas.width / WIDTH;
            const cellH = mazeCanvas.height / HEIGHT;
            mazeCtx.fillStyle = '#12121a';
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            for (let i = 0; i < HEIGHT; i++) {
                for (let j = 0; j < WIDTH; j++) {
                    const x = j * cellW;
                    const y = (HEIGHT - 1 - i) * cellH;
                    const s = env.posToState(i, j);
                    if (walls[i][j] === 1) {
                        mazeCtx.fillStyle = '#2a2a35';
                    } else if (s === START_STATE) {
                        mazeCtx.fillStyle = '#5a9a7a';
                    } else {
                        const sim = goalSimilarity(s);
                        const t = (sim + 1) / 2;
                        const r = Math.floor(90 + 90 * (1 - t));
                        const g = Math.floor(120 - 20 * (1 - t));
                        const b = Math.floor(160 - 70 * (1 - t));
                        mazeCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    }
                    mazeCtx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
                }
            }

            // Goal marker
            const [gi, gj] = stateToPos(GOAL_STATE);
            const gx = (gj + 0.5) * cellW;
            const gy = (HEIGHT - 1 - gi + 0.5) * cellH;
            mazeCtx.fillStyle = '#6699bb';
            mazeCtx.beginPath();
            mazeCtx.arc(gx, gy, cellW * 0.3, 0, Math.PI * 2);
            mazeCtx.fill();

            // Trajectory
            if (currentTraj.length > 1) {
                mazeCtx.strokeStyle = currentTrajSuccess ? '#6ab07a' : '#bba866';
                mazeCtx.lineWidth = 2;
                mazeCtx.beginPath();
                for (let t = 0; t < currentTraj.length; t++) {
                    const [ti, tj] = stateToPos(currentTraj[t]);
                    const tx = (tj + 0.5) * cellW;
                    const ty = (HEIGHT - 1 - ti + 0.5) * cellH;
                    if (t === 0) mazeCtx.moveTo(tx, ty);
                    else mazeCtx.lineTo(tx, ty);
                }
                mazeCtx.stroke();
            }
        }

        // ============================================
        // THREE.JS VISUALIZATION
        // ============================================
        const reprPanel = document.getElementById('repr-panel');
        let viewMode = 'pca3d';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x12121a);

        const aspect = reprPanel.clientWidth / reprPanel.clientHeight;
        const frustumSize = 2.5;
        const orthoCamera = new THREE.OrthographicCamera(
            -frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 100
        );
        orthoCamera.position.set(0, 0, 5);

        const perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 100);
        perspCamera.position.set(2, 1.5, 2);

        let activeCamera = perspCamera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(reprPanel.clientWidth, reprPanel.clientHeight);
        reprPanel.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(perspCamera, renderer.domElement);
        controls.enableDamping = true;

        // Unit circle
        const circleGeom = new THREE.BufferGeometry();
        const circlePoints = [];
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
            circlePoints.push(Math.sin(angle), Math.cos(angle), 0);
        }
        circleGeom.setAttribute('position', new THREE.Float32BufferAttribute(circlePoints, 3));
        const circleLine = new THREE.Line(circleGeom, new THREE.LineBasicMaterial({ color: 0x666688, transparent: true, opacity: 0.6 }));
        scene.add(circleLine);

        // Sphere wireframe
        const sphereWire = new THREE.Mesh(
            new THREE.SphereGeometry(1, 24, 24),
            new THREE.MeshBasicMaterial({ color: 0x333355, wireframe: true, transparent: true, opacity: 0.15 })
        );
        scene.add(sphereWire);

        // Axes
        const axesMat = new THREE.LineBasicMaterial({ color: 0x444466 });
        const yAxisGeom = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -1.2, 0), new THREE.Vector3(0, 1.2, 0)
        ]);
        scene.add(new THREE.Line(yAxisGeom, axesMat));
        const xAxisGeom = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-1.2, 0, 0), new THREE.Vector3(1.2, 0, 0)
        ]);
        scene.add(new THREE.Line(xAxisGeom, axesMat));
        const zAxisGeom = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -1.2), new THREE.Vector3(0, 0, 1.2)
        ]);
        const zAxis = new THREE.Line(zAxisGeom, axesMat);
        scene.add(zAxis);

        // State meshes
        const stateMeshes = [];
        for (let s = 0; s < NUM_STATES; s++) {
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.035, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x4488ff })
            );
            scene.add(mesh);
            stateMeshes.push(mesh);
        }

        let prevPC1 = null, prevPC2 = null;

        function computeZetaPCA() {
            const zetas = [], stateIndices = [];
            for (let s = 0; s < NUM_STATES; s++) {
                const [i, j] = stateToPos(s);
                if (walls[i][j] === 1) continue;
                const c = goalSimilarity(s);
                const zeta = [];
                for (let d = 0; d < REP_DIM; d++) {
                    zeta.push(representation.psi[s][d] - c * representation.psiGoal[d]);
                }
                zetas.push(zeta);
                stateIndices.push(s);
            }
            if (zetas.length === 0) return { projections1: {}, projections2: {} };

            const mean = new Array(REP_DIM).fill(0);
            for (const z of zetas) for (let d = 0; d < REP_DIM; d++) mean[d] += z[d];
            for (let d = 0; d < REP_DIM; d++) mean[d] /= zetas.length;
            const centered = zetas.map(z => z.map((v, d) => v - mean[d]));

            let pc1 = prevPC1 ? prevPC1.slice() : new Array(REP_DIM).fill(0).map(() => Math.random() - 0.5);
            normalize(pc1);
            for (let iter = 0; iter < 50; iter++) {
                const newPc = new Array(REP_DIM).fill(0);
                for (const z of centered) {
                    const proj = dot(z, pc1);
                    for (let d = 0; d < REP_DIM; d++) newPc[d] += proj * z[d];
                }
                normalize(newPc);
                pc1 = newPc;
            }
            if (prevPC1 && dot(pc1, prevPC1) < 0) for (let d = 0; d < REP_DIM; d++) pc1[d] = -pc1[d];
            prevPC1 = pc1.slice();

            let pc2 = prevPC2 ? prevPC2.slice() : new Array(REP_DIM).fill(0).map(() => Math.random() - 0.5);
            let proj1 = dot(pc2, pc1);
            for (let d = 0; d < REP_DIM; d++) pc2[d] -= proj1 * pc1[d];
            normalize(pc2);
            for (let iter = 0; iter < 50; iter++) {
                const newPc = new Array(REP_DIM).fill(0);
                for (const z of centered) {
                    const proj = dot(z, pc2);
                    for (let d = 0; d < REP_DIM; d++) newPc[d] += proj * z[d];
                }
                proj1 = dot(newPc, pc1);
                for (let d = 0; d < REP_DIM; d++) newPc[d] -= proj1 * pc1[d];
                normalize(newPc);
                pc2 = newPc;
            }
            if (prevPC2 && dot(pc2, prevPC2) < 0) for (let d = 0; d < REP_DIM; d++) pc2[d] = -pc2[d];
            prevPC2 = pc2.slice();

            const projections1 = {}, projections2 = {};
            for (let i = 0; i < zetas.length; i++) {
                projections1[stateIndices[i]] = dot(zetas[i], pc1);
                projections2[stateIndices[i]] = dot(zetas[i], pc2);
            }
            return { projections1, projections2 };
        }

        function updateReprView() {
            if (!representation.psi) return;

            const is3D = viewMode === 'pca3d';
            circleLine.visible = viewMode === 'pca2d';
            sphereWire.visible = is3D;

            if (is3D) {
                activeCamera = perspCamera;
                controls.enabled = true;
            } else {
                activeCamera = orthoCamera;
                controls.enabled = false;
            }

            let pcaData = null;
            if (viewMode !== 'magnitude') pcaData = computeZetaPCA();

            for (let s = 0; s < NUM_STATES; s++) {
                const [i, j] = stateToPos(s);
                if (walls[i][j] === 1) { stateMeshes[s].visible = false; continue; }
                stateMeshes[s].visible = true;

                const c = goalSimilarity(s);
                let x = 0, y = c, z = 0;

                if (viewMode === 'magnitude') {
                    x = Math.sqrt(Math.max(0, 1 - c * c));
                } else {
                    x = pcaData.projections1[s] || 0;
                    z = is3D ? (pcaData.projections2[s] || 0) : 0;
                }

                stateMeshes[s].position.set(x, y, z);

                const t = (c + 1) / 2;
                let color;
                if (s === GOAL_STATE) color = 0x6699bb;
                else if (s === START_STATE) color = 0x5a9a7a;
                else {
                    const r = Math.floor(90 + 90 * (1 - t));
                    const g = Math.floor(120 - 20 * (1 - t));
                    const b = Math.floor(160 - 70 * (1 - t));
                    color = (r << 16) | (g << 8) | b;
                }
                stateMeshes[s].material.color.setHex(color);
            }
        }

        function resizeReprView() {
            const w = reprPanel.clientWidth, h = reprPanel.clientHeight;
            const aspect = w / h;
            orthoCamera.left = -frustumSize * aspect;
            orthoCamera.right = frustumSize * aspect;
            orthoCamera.updateProjectionMatrix();
            perspCamera.aspect = aspect;
            perspCamera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }

        // ============================================
        // SIMULATION
        // ============================================
        let episode = 0, successCount = 0, isPlaying = false;

        function runEpisode() {
            const result = agent.collectEpisode();
            currentTraj = result.traj;
            currentTrajSuccess = result.success;
            if (result.success) successCount++;
            agent.updateRepresentations();
            episode++;
            updateStats();
        }

        function updateStats() {
            document.getElementById('stat-episode').textContent = episode;
            document.getElementById('stat-success-rate').textContent = episode > 0 ? Math.round(100 * successCount / episode) + '%' : '0%';
        }

        function reset() {
            episode = 0;
            successCount = 0;
            currentTraj = [];
            isPlaying = false;
            agent.init();
            prevPC1 = null;
            prevPC2 = null;
            updateStats();
            drawMaze();
            updateReprView();
            document.getElementById('btn-play').textContent = '▶ Play';
            document.getElementById('controls-toggle').textContent = '▶ Play';
        }

        // Controls
        const controlsPanel = document.getElementById('controls-panel');
        document.getElementById('controls-toggle').addEventListener('click', () => {
            if (!controlsPanel.classList.contains('visible')) {
                controlsPanel.classList.add('visible');
            } else {
                isPlaying = !isPlaying;
                const txt = isPlaying ? '⏸ Pause' : '▶ Play';
                document.getElementById('btn-play').textContent = txt;
                document.getElementById('controls-toggle').textContent = txt;
            }
        });

        document.getElementById('btn-play').addEventListener('click', () => {
            isPlaying = !isPlaying;
            const txt = isPlaying ? '⏸ Pause' : '▶ Play';
            document.getElementById('btn-play').textContent = txt;
            document.getElementById('controls-toggle').textContent = txt;
        });

        document.getElementById('btn-reset').addEventListener('click', reset);

        document.getElementById('btn-view-pca3d').addEventListener('click', () => {
            viewMode = 'pca3d';
            document.querySelectorAll('.view-btns button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-view-pca3d').classList.add('active');
            updateReprView();
        });
        document.getElementById('btn-view-pca2d').addEventListener('click', () => {
            viewMode = 'pca2d';
            document.querySelectorAll('.view-btns button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-view-pca2d').classList.add('active');
            updateReprView();
        });
        document.getElementById('btn-view-magnitude').addEventListener('click', () => {
            viewMode = 'magnitude';
            document.querySelectorAll('.view-btns button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-view-magnitude').classList.add('active');
            updateReprView();
        });

        // Animation
        let lastUpdate = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            if (isPlaying && time - lastUpdate > 100) {
                runEpisode();
                drawMaze();
                updateReprView();
                lastUpdate = time;
            }
            if (viewMode === 'pca3d') controls.update();
            renderer.render(scene, activeCamera);
        }

        window.addEventListener('resize', () => {
            resizeMazeCanvas();
            resizeReprView();
            drawMaze();
            updateReprView();
        });

        // Init
        resizeMazeCanvas();
        reset();
        animate(0);
    </script>
</body>
</html>
